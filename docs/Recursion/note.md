## 재귀(recursion) vs 공재귀(co-recursion)

> 재귀 함수는 일반적으로 연산의 일부분으로 자기 자신을 호출하는 함수를 의미하는데,  
> 자기 자신을 호출하는 시점이 언제이냐에 따라 일반 재귀함수와 공재귀함수로 나뉜다.  
>
> 먼저, 재귀 함수란 함수 내에서 모든 연산을 종료하기 전에 자기 자신을 호출하는 함수를  
> 말한다. 재귀 함수 내부에는 더 이상 재귀적 호출이 발생하지 않도록 분기하는 종료 조건이  
> 포함되어 있어 무한 루프에 빠지는 것을 방지한다. 이러한 재귀 함수는 함수내의 모든 연산을   
> 종료하기 전 자기 자신을 호출는 것을 반복하며 스택을 열고 더 깊은 내부로 진입을 반복한다.   
> 그리고 더 이상 호출이 일어나지 않는 종료 조건에 이르러서야 제일 최근에 열린 스택을 닫고   
> 반환된 결과에 남은 연산을 적용해 나간다.
> 
> 이러한 재귀 함수의 계산 방식에는 한 가지 문제가 있는데, 그것은 재귀호출로부터 반환값을  
> 얻어야 남은 연산을 진행할 수 있기 때문에, 새로운 스택이 열릴 때마다 이전 단계의 지연된   
> 연산까지 누적해서 메모리에 기록해야 한다는 것이다. 그래서 스택의 깊이가 깊어질수록 하나의   
> 스택이 필요로 하는 메모리의 크기가 증가하게 되고, 빠르게 스택 메모리를 소진시킨다. 그리고   
> 실행환경이 허용하는 스택의 크기를 벗어나는 경우에는 스택 오버플로우 오류를 발생시키며   
> 프로그램을 비정상적으로 종료시킨다.
>
> 한편, 공재귀 함수는 함수 내에서의 모든 연산을 끝낸 뒤 자기 자신을 호출하여 다음 계산을  
> 이어나가는 함수를 말한다. 재귀 함수와 마찬가지로 공재귀 함수 또한 분기문에 재귀 호출에   
> 대한 종료 조건이 포함되어 있어 무한 루프를 방지한다. 공재귀 함수도 함수의 실행이 종료되기   
> 전 자신을 계속해서 호출해 나간다는 점은 재귀 함수와 같지만, 새로운 스택이 열리기 전 기존   
> 스택에서 모든 연산이 종료되고 다음 스택을 호출할 때 하나의 인자 값으로 전달되기 때문에   
> 스택이 열릴 때마다 필요한 메모리의 크기가 일정하다. 따라서 공재귀 함수도 스택의 깊이가  
> 깊어질수록 스택 메모리의 총사용량은 증가하지만 재귀 함수에 비해 스택 사용량이 적기 때문에   
> 재귀보다는 스택 오버플로우 오류가 발생하는 속도가 느리다.

<br/>

#### 재귀 함수

* 구현 방식

```kotlin
fun prepend(c: Char, s: String): String = "$c$s"

fun toString(list: List<Char>): String {
    fun toString(list: List<Char>, s: String): String =
        if (list.isEmpty()) {
            println("""$list, "$s"""".trimMargin())
            s
        }
        else {
            val str1 = """$list + "$s" => ${list.subList(0, list.size - 1)}"""
            val str2 = """'${list[list.size - 1]}' + "$s"""".trimMargin()
            println("$str1 $str2")

            // ----------------------------------------------------- //
            // 재귀 호출 toString(...)을 실질적인 연산 prepend 이전에 실시한다
            // ----------------------------------------------------- //

            toString(list.subList(0, list.size - 1), prepend(list[list.size - 1], s))

            // ----------------------------------------------------- //
        }
    return toString(list, "")
}

println(""""${toString(listOf('a','b','c'))}"""")


실행결과: 

[a, b, c] + "" => [a, b] 'c' + ""
[a, b] + "c" => [a] 'b' + "c"
[a] + "bc" => [] 'a' + "bc"
[], "abc"
"abc"
```

#### 공재귀 함수

* 구현 방식