## 선행조건과 불변식 (제자리 상태 변이를 피해야 하는 이유)

> 수학에서 증명된 이론적 명제로서 정리가 작동하는 방식은 일반적으로 다음과 같이 요약된다.   
> 첫째, 일정한 연산과 구조가 부여된 집합으로서의 공간(space)을 전체 집합으로 정리가    
> 증명하고자 하는 연산이 적용될 대상이 특정 집합으로 한정되는 조건이 기술된다.  
> 둘째, 기술된 집합이 부가적으로 갖춰야할 조건 또는 연산이 기술된다. 셋쩨,   
> 조건이 만족되었을 때 기술된 집합이 얻게되는 수학적 속성들이 결론부에 제시된다. 
>
> 이러한 정리는 특정 집합으로 한정하는 조건 `(선행조건)`과 부가적으로 갖춰야할 조건 `(불변식)`이   
> 만족되면 결론이 제시하는 수학적 속성 `(결과)` 를 항상 얻을 수 있도록 설계되어 있다. 그리고   
> 이는 베트란트 마이어가 에펠을 설계할 때 적용했던 `계약에 의한 설계`적인 관점과도 궤를 같이한다.  
> 객체 지향에서의 클래스 메서드가 항상 예상한 것과 같이 정확하게 작동하도록 위해서는 수학에서 정리와  
> 마찬가지로 가지는 세 가지 요소로 `(선행조건, 불변식, 결과)` 기술될 수 있어야 하는 것이다. 
>
> 이와 관련하여 컴퓨터 공학에서 `제자리 상태 변이(in place algorithm)`는 `선행조건` 또는   
> `불변식`으로 입력된 자료값을 덮어쓰는 것을 계산 방식을 말한다. 그런데 앞서 이야기 한 바와 같이  
> 수학의 정리나 객체 지향에서의 계약에 의한 설계가 항상 일정한 결론을 보장되는 것은 바로 선행조건과  
> 불변식이 만족되기 떄문이다. 따라서 제자리 상태 변이로 인해 선행조건 또는 불변식이 훼손된다면  
> 항상 동일한 결과가 얻어진다고 보장할 수 없기 때문에, 제자리 상태 변이는 피해야 하는 안티 패턴이다.  


#### 언어 구현에서 제자리 상태 변이가 제한된 사례

* for each loop에서의 iterator 변경 금지

* 람다 클로저 변수의 변경 금지


