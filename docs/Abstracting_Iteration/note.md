## 반복의 추상화 (왜 필요한가?)

> 확정적이고 고정된 소스 코드가 현실의 다양한 문제를 해결할 수 있는 프로그램으로 승격되기   
> 위해서는 다음의 몇 가지 조건이 충족되어야 한다.   
> 
> 첫째, 프로그램 `외부로부터 다양한 값을 실시간으로 입력` 받을 수 있어야 한다. 사용자의   
> 입력에 따라 다른 결과를 얻을 수 없다면, 소스 코드는 작성한 글만 화면에 보여주는 전자화된   
> 메모지에 지나지 않는다. 
> 
> 둘째, 프로그램 외부로 입력된 값에 따라 서로 다른 처리가 가능하도록 소스 코드 내부에 서로  
> 다른 상태 값에 대한 `분기 처리가 가능`해야 한다. 외부로부터 다양한 값을 입력받을 수 있음에도  
> 입력값에 무관하게 같은 처리만 가능한 프로그램이라면, 말한 내용을 그대로 흉내내어 말하는   
> 앵무새나 카세트 테이프 레코더와 크게 다르다고 볼 수 없다.  
>
> 한편 어셈블러와 같은 저수준까지 내려가면 `분기 처리는 사실상 goto 문`과 같은 건너 뛰기이다.  
> 이러한 goto 문은 건너 뛰기 이상의 의미를 가지고 있지 않기 때문에, `키워드를 읽는 것만으로는`  
> `프로그램의 흐름을 읽기 어렵다는 단점`이 있다. 
> 
> 하지만 일반적으로 프로그램에서 goto 문이 사용되는 컨텍스트는 반복, 단일 조건 분기, 다중  
> 조건 분기 등을 크게 벗어나지 않는다. 그리고 이러한 의도를 구문에 반영시켜 `goto문`을   
> `추상화`한 것이 현대 언어의 if then else, for/while/loop, switch 키워드를 이용한  
> 구조적인 프로그래밍이다. 
>
> 그런데 이러한 추상화는 구문 단위에서만 가능한 것이 아니다. 상기와 같은 구문 추상화는    
> 매번 `제어 로직이 바뀔 때마다 새로 작성하는 한계가 존재`하는데, `다형적 함수(Generic`   
> `Function) 레벨로 분기, 반복을 추상화`하는 데 성공한다면, 프로그래머는 제어 로직의   
> 복잡성은 추상화된 함수 아래로 숨긴 채 제어 구문을 간편하게 작성할 수 있다.
>

### 제어문 추상화 구현 방식

#### 재귀적 방식

* 재귀 함수를 이용한 방법

* 공재귀 함수를 이용한 방법

* 메모화를 이용한 방법

#### 객체지향적 방식

* Generic for loop를 이용한 방법

* iterator를 이용한 방법

* decorator 연쇄를 이용하는 방법

#### 함수형 방식

* prediciate을 이용한 방법

* fold를 이용한 방법

